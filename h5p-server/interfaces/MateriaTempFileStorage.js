import { H5pError, Logger } from "@lumieducation/h5p-server";

const fsextra = require("fs-extra");
const fs = require("fs");
const request = require("request-promise");
const promisepipe = require("promisepipe");
const path = require("path");
const crypto = require("crypto");

const log = new Logger("MateriaTempFileStorage");

// instructs node to allow untrusted certificates
// when uploading images to materia
// only for use in development
if (process.env.ENVIRONMENT != "prod") {
  process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0";
}

export default class MateriaTempFileStorage {
  constructor() {}

  /**
   * this gets called when a user uploads a new media file in an h5p widget creator
   *
   * Saves the file to temp directory then uploads to Materia
   * @param filename: string auto generated by h5p
   * @param dataStream: PassThrough (Read/Write stream) generated by h5p. not compatible with materia
   * @param user: h5p user object, user.id for materia should always be 1
   * @param expiration time: set for an hour after upload
   */
  async saveFile(filename, dataStream, user, expirationTime) {
    if (!filename) {
      log.error(`Filename empty!`);
      throw new H5pError("illegal-filename", {}, 400);
    }

    // create the file in a temporary directory
    // use this file to upload to materia
    await fsextra.ensureDir(this.getAbsoluteUserDirectoryPath(user.id));
    const filePath = this.getAbsoluteFilePath(user.id, filename);
    await fsextra.ensureDir(path.dirname(filePath));
    const writeStream = fsextra.createWriteStream(filePath);
    await promisepipe(dataStream, writeStream);
    await fsextra.writeJSON(`${filePath}.metadata`, {
      expiresAt: expirationTime.getTime()
    });

    // upload to materia process
    try {
      // create a readstream with the temp file
      const stream = fs.createReadStream(filePath);

      //oauth token
      const timestamp = Math.floor(new Date().getTime() / 1000).toString();
      const nonce = crypto.randomBytes(16).toString("hex");
      const token = crypto
        .createHmac("sha256", process.env.OAUTH_SECRET + timestamp + nonce)
        .update(process.env.OAUTH_KEY)
        .digest("hex");
      const materiaHost = process.env.MATERIA_WEBSERVER_NETWORK || "localhost";

      // set up post request with multiform-data
      var options = {
        method: "POST",
        url: `https://${materiaHost}/media/upload`,
        formData: {
          "Content-Type": "image/png", //todo get actual content type
          file: {
            value: stream,
            options: {
              filename: filename,
              contentType: null
            }
          },
          name: filename,
          oauth_consumer_key: process.env.OAUTH_KEY,
          oauth_timestamp: timestamp,
          oauth_nonce: nonce,
          oauth_signature: token
        }
      };

      // create a filename using the materia media ID that is
      // returned to us from the upload request
      var materiaFilename = "";

      await request(options, function(error, response) {
        if (error) throw new Error(error);
        if (response.statusCode == 404)
          throw new Error("Unable to upload file to Materia");
        // response should look like {"success": "true", "id": "5-digit-random-hash"}
        response.body = JSON.parse(response.body);

        // rename the temp file to materia ID hash so
        // we can insert it in the materia qset later
        const dir = filename.match(/[^\/]*\//); // something like "images/"
        const filetype = filename.match(/\.[0-9a-z]+$/i); // something like ".png"
        materiaFilename = dir + response.body.id + filetype;
        fs.rename(
          path.join("./h5p/temporary-storage/", user.id, filename),
          path.join("./h5p/temporary-storage/", user.id, materiaFilename),
          error => {
            if (error) {
              console.log("error renaming files");
              console.log(error);
            } else {
              // also need to rename the metadata file so
              // h5p knows where to find the file stats
              fs.rename(
                path.join(
                  "./h5p/temporary-storage/",
                  user.id,
                  filename + ".metadata"
                ),
                path.join(
                  "./h5p/temporary-storage/",
                  user.id,
                  materiaFilename + ".metadata"
                ),
                error => {
                  if (error) {
                    console.log("error renaming metadata files");
                    console.log(error);
                  }
                }
              );
            }
          }
        );
      });

      // return the file object so h5p creator can retrieve it
      return {
        expiresAt: expirationTime,
        filename: materiaFilename,
        ownedByUserId: user.id
      };
    } catch (error) {
      log.error(
        `Error while uploading file "${filename}" to Materia storage: ${error.message}`
      );
      throw new H5pError(
        `temporary-storage:materia-upload-error`,
        { filename },
        500
      );
    }
  }

  // helper function simply generates temp file path
  // for h5p creator to find media
  getAbsoluteFilePath(userId, filename) {
    return path.join("./h5p/temporary-storage/", userId, filename);
  }

  // generate users directory for temp file storage
  // in materia's case userId will always be 1
  getAbsoluteUserDirectoryPath(userId) {
    return path.join("./h5p/temporary-storage/", userId);
  }

  // returns an object representing a file using metadata to get
  // its expire time
  async getTempFileInfo(userId, filename) {
    const metadata = await fsextra.readJSON(
      `${this.getAbsoluteFilePath(userId, filename)}.metadata`
    );
    return {
      expiresAt: new Date(metadata.expiresAt),
      filename,
      ownedByUserId: userId
    };
  }

  /**
   * Checks if a file exists in temporary storage.
   * @param filename the file to check
   * @param user the user who wants to access the file
   */
  async fileExists(filename, user) {
    const filePath = this.getAbsoluteFilePath(user.id, filename);
    return fsextra.pathExists(filePath);
  }

  /**
   * Removes a file from temporary storage. Will silently do nothing if the file does not
   * exist or is not accessible.
   * @param filename
   * @param user
   */
  async deleteFile(filename, userId) {
    const filePath = this.getAbsoluteFilePath(userId, filename);
    fsextra.remove(filePath);
    fsextra.remove(`${filePath}.metadata`);
  }

  /**
   * List all files in temporary storage, from both the images/ and videos/ directories,
   * and append them together. removes each corresponding .metadata file from the list
   * @returns an object for each file of the form
   *  {
   *    expiresAt: DateTime,
   *    filename,
   *    ownedByUserId: userID
   *  }
   */
  async listFiles() {
    // get list of files from images/ directory
    let result = await fsextra.readdir("./h5p/temporary-storage/1/images");
    // prepend images/ to each file
    result = result.map(file => "images/" + file);

    // get list of files from /videos direcotry
    let videoResults = await fsextra.readdir(
      "./h5p/temporary-storage/1/videos"
    );
    // prepend videos/ to each file
    videoResults = videoResults.map(file => "videos/" + file);

    // concatenate the two arrays to get all temporary files in one array
    result = result.concat(videoResults);

    // remove all metadata files from the array
    result = result.filter(file => !file.endsWith(".metadata"));
    // create object for each file, which includes expire time and user owner
    result = await Promise.all(
      result.map(file => this.getTempFileInfo("1", file))
    );
    return result;
  }

  /**
   * Returns a information about a temporary file.
   * Throws an exception if the file does not exist.
   * @param filename the relative path inside the library
   * @param user the user who wants to access the file
   * @returns the file stats
   */
  async getFileStats(filename, user) {
    if (!(await this.fileExists(filename, user))) {
      throw new H5pError(
        "storage-file-implementations:temporary-file-not-found",
        {
          filename,
          userId: user.id
        },
        404
      );
    }
    const filePath = this.getAbsoluteFilePath(user.id, filename);
    return fsextra.stat(filePath);
  }

  /**
   * Returns a readable for a file.
   *
   * Note: Make sure to handle the 'error' event of the Readable! This method
   * does not check if the file exists in storage to avoid the extra request.
   * However, this means that there will be an error when piping the Readable
   * to the response if the file doesn't exist!
   * @param filename
   * @param user
   */
  async getFileStream(filename, user) {
    const filePath = this.getAbsoluteFilePath(user.id, filename);
    if (!(await fsextra.pathExists(filePath))) {
      throw new H5pError(
        "storage-file-implementations:temporary-file-not-found",
        { filename, userId: user.id },
        404
      );
    }
    return fsextra.createReadStream(filePath);
  }
}
